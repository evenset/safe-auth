import crypto from 'crypto';
import {AccessToken as AccessToken, User as User} from '../models';
import Stored from './storage';

/*
 * AccessToken class implemented to use dummy in memory database
 */
export class MemoryAccessToken extends
    Stored<AccessToken, typeof AccessToken>(AccessToken) {
    /**
     * Token string - autogenerated no need to be filled
     */
    public token: string;
    /**
     * Refresh token string - autogenerated no need to be filled
     */
    public refreshToken: string;
    /**
     * Timestamp in which this token will get expired, it only affects `token`
     * and has no effect on `refreshToken`
     */
    public expires: Date|null;
    /**
     * The user that this access token belongs to
     */
    public user: User;
    /**
     * Indicates that whether `refreshToken` is used or not, as soon as it's
     * used this field will be true and the `AccessToken` instance will become
     * inactive
     */
    protected consumed: boolean;

    /**
     * Creates an AccessToken for a user setting its expiration date
     */
    public constructor({user, expires}: {user: User; expires: Date|null}) {
        super();
        this.token = crypto
            .randomBytes(22)
            .toString('base64')
            .replace(/=*$/g, '');
        this.refreshToken = crypto
            .randomBytes(22)
            .toString('base64')
            .replace(/=*$/g, '');
        this.user = user;
        this.expires = expires;
        this.consumed = false;
    }

    /**
     * Looks an AccessToken up in memory based on its token, refreshToken,
     * userId, its expired status, its consumed status or its active status
     *
     * @param {Object} filters Filters object
     * @param {string} filters.token Token
     * @param {string} filters.refreshToken Refresh token
     * @param {number} filters.userId User
     * @param {boolean} filters.isExpired Expired status
     * @param {boolean} filters.isConsumed Consumed status
     * @param {boolean} filters.isActive Activation status
     */
    public static async first({
        token,
        refreshToken,
        userId,
        isExpired,
        isConsumed,
        isActive,
    }: {
        /** Token */
        token?: string;
        /** Refresh token */
        refreshToken?: string;
        /** User */
        userId?: number;
        /** Expired */
        isExpired?: boolean;
        /** Consumed */
        isConsumed?: boolean;
        /** Active */
        isActive?: boolean;
    }): Promise<MemoryAccessToken|null> {
        const items = Object.values(this.items)
            .filter((item): boolean => (
                (token === undefined || item.token === token) &&
                (
                    refreshToken === undefined ||
                    item.refreshToken === refreshToken
                ) &&
                (userId === undefined || item.user.id === userId) &&
                (isExpired === undefined || item.isExpired() === isExpired) &&
                (
                    isConsumed === undefined ||
                    item.isConsumed() === isConsumed
                ) &&
                (isActive === undefined || item.isActive() === isActive)
            ));
        return (items[0] as MemoryAccessToken) || null;
    }

    /**
     * Looks up AccessTokens in memory based on its userId, its expired status,
     * its consumed status or its active status
     *
     * @param {Object} filters Filters object
     * @param {number} filters.userId User
     * @param {boolean} filters.isExpired Expired status
     * @param {boolean} filters.isConsumed Consumed status
     * @param {boolean} filters.isActive Activation status
     */
    public static async filter({userId, isExpired, isConsumed, isActive}: {
        /** User */
        userId?: number;
        /** Expired */
        isExpired?: boolean;
        /** Consumed */
        isConsumed?: boolean;
        /** Active */
        isActive?: boolean;
    }): Promise<MemoryAccessToken[]> {
        return Object.values(this.items)
            .filter((item): boolean => (
                (userId === undefined || item.user.id === userId) &&
                (isExpired === undefined || item.isExpired() === isExpired) &&
                (
                    isConsumed === undefined ||
                    item.isConsumed() === isConsumed
                ) &&
                (isActive === undefined || item.isActive() === isActive)
            )) as MemoryAccessToken[];
    }
}

/*
 * User class implemented to use in memory dummy database
 */
export class MemoryUser extends Stored<User, typeof User>(User) {
    /**
     * A reference to the AccessToken class that's going to be used in
     * internal methods of User class
     */
    protected static AccessTokenClass = MemoryAccessToken;
    /**
     * User's username (unique)
     */
    public username: string;
    /**
     * User's password stored as a hash
     */
    public password: string;
    /**
     * Stores whether the user is active or not in a boolean
     */
    public isActive: boolean;

    /**
     * Creates a User by its username and password
     */
    public constructor({username, password}: {
        username: string;
        password: string;
    }) {
        super();
        this.username = username;
        this.password = User.hashPassword(password);
        this.isActive = false; // TODO: Configuration
    }

    /**
     * Looks a User up in memory based on its id or username
     *
     * @param {Object} filters Filters object
     * @param {number} filters.id Id
     * @param {strign} filters.username Username
     * @param {boolean} filters.isActive Activation status
     */
    public static async first({id, username, isActive}: {
        /** Id */
        id?: number;
        /** Username*/
        username?: string;
        /** Active */
        isActive?: boolean;
    }): Promise<MemoryUser|null> {
        const items = Object.values(id !== undefined
            ? [this.items[id]]
            : this.items)
            .filter((item): boolean => (
                (username === undefined || item.username === username) &&
                (isActive === undefined || item.isActive === isActive)
            ));
        return items[0] || null;
    }
}
